<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>平行板電場模擬</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <style>
    /* --- 基礎設定 (與 index.html 相同) --- */
    body { 
      margin: 0; overflow: hidden; background: #000; 
      font-family: 'Segoe UI', Arial, sans-serif; 
      touch-action: none; 
      user-select: none; -webkit-user-select: none;
    }

    /* --- 側邊選單 --- */
    #side-menu {
      position: fixed; top: 0; left: -260px;
      width: 260px; height: 100%;
      background: rgba(25, 25, 25, 0.98);
      box-shadow: 2px 0 10px rgba(0,0,0,0.5);
      z-index: 2000; transition: left 0.3s ease;
      display: flex; flex-direction: column;
      border-right: 1px solid #444;
    }
    #side-menu.open { left: 0; }
    .menu-header {
      padding: 20px; background: #222; border-bottom: 1px solid #444;
      display: flex; justify-content: space-between; align-items: center;
    }
    .menu-title { color: #fff; font-weight: bold; font-size: 18px; }
    .close-btn { color: #aaa; font-size: 24px; cursor: pointer; padding: 5px; }
    .menu-items { padding: 10px 0; }
    .menu-link {
      display: block; padding: 15px 20px;
      color: #ddd; text-decoration: none;
      font-size: 16px; border-bottom: 1px solid #333;
      transition: background 0.2s;
    }
    .menu-link:hover { background: #333; color: #fff; }
    /* 設定 active 樣式 */
    .menu-link.active { background: #333; color: #fff; border-left: 4px solid #00ffff; }

    #menu-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 1500; display: none; backdrop-filter: blur(2px);
    }
    #menu-overlay.open { display: block; }

    /* --- 頂部控制列 (針對平行板客製化) --- */
    #top-bar {
      position: fixed; top: 0; left: 0; width: 100%;
      background: rgba(20,20,20,0.9); padding: 10px 0;
      display: flex; flex-direction: column; align-items: center; 
      gap: 8px; z-index: 100;
      backdrop-filter: blur(5px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    
    #menu-btn {
      position: absolute; left: 15px; top: 15px;
      background: none; border: none; color: white; font-size: 24px;
      cursor: pointer; padding: 5px; z-index: 110;
    }

    /* 滑桿控制區 */
    .slider-container {
      display: flex; align-items: center; gap: 10px; width: 90%; max-width: 400px;
      color: #fff; font-size: 14px;
    }
    .slider-label { width: 80px; text-align: right; }
    input[type=range] { flex-grow: 1; }
    
    /* 底部數據 HUD */
    #hud {
      position: fixed; bottom: 0; left: 0; width: 100%;
      background: rgba(10,10,10,0.9); color: white;
      padding: 15px 10px; box-sizing: border-box;
      display: flex; justify-content: space-around;
      font-family: 'Courier New', monospace; z-index: 20; 
      border-top: 1px solid #444;
    }
    .hud-item { text-align: center; }
    .hud-label { display: block; font-size: 12px; color: #aaa; margin-bottom: 2px; }
    .hud-val { font-size: 1.2rem; font-weight: bold; letter-spacing: 1px; }
    .unit { font-size: 0.9rem; color: #888; margin-left: 3px; }

    #hint {
      position: absolute; bottom: 80px; width: 100%; text-align: center;
      color: rgba(255,255,255,0.4); font-size: 12px; pointer-events: none;
    }
  </style>
</head>
<body>

  <!-- 遮罩層 -->
  <div id="menu-overlay" onclick="toggleMenu()"></div>

  <!-- 側邊選單 -->
  <nav id="side-menu">
    <div class="menu-header">
      <span class="menu-title">物理模擬實驗室</span>
      <span class="close-btn" onclick="toggleMenu()">×</span>
    </div>
    <div class="menu-items">
      <a href="index.html" class="menu-link">1. 點電荷電場模擬</a>
      <!-- 當前頁面 active -->
      <a href="parallel.html" class="menu-link active">2. 平行板電場模擬</a>
      <a href="#" class="menu-link" onclick="alert('建置中...')">3. 磁場模擬 (範例)</a>
    </div>
  </nav>

  <!-- 頂部控制列 -->
  <div id="top-bar">
    <button id="menu-btn" onclick="toggleMenu()">☰</button>
    
    <div class="slider-container" style="margin-top: 5px;">
      <span class="slider-label">帶電量 Q</span>
      <input type="range" id="chargeSlider" min="1" max="10" step="0.5" value="5" oninput="updateParams()">
      <span id="q-display" style="width: 35px">5C</span>
    </div>
    <div class="slider-container">
      <span class="slider-label">板間距 d</span>
      <input type="range" id="distSlider" min="50" max="250" step="10" value="150" oninput="updateParams()">
      <span id="d-display" style="width: 35px">mm</span>
    </div>
  </div>

  <div id="hint">移動滑桿調整參數 | 拖曳黃色準心觀測內部電場</div>

  <!-- 底部數據 -->
  <div id="hud">
    <div class="hud-item">
      <span class="hud-label">電場強度 E</span>
      <span id="e-val" class="hud-val" style="color:#00ffff">0.00</span>
      <span class="unit">N/C</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">電位 V</span>
      <span id="v-val" class="hud-val">0.00</span>
      <span class="unit">V</span>
    </div>
  </div>

  <script>
    // --- 選單控制 ---
    function toggleMenu() {
      const menu = document.getElementById('side-menu');
      const overlay = document.getElementById('menu-overlay');
      menu.classList.toggle('open');
      overlay.classList.toggle('open');
    }

    // --- 物理模擬參數 ---
    const PLATE_CHARGES_COUNT = 16; // 每一片板子由多少個點電荷組成
    const PLATE_WIDTH = 300;        // 板子總長度 (px)
    const K_CONST = 5000;           // 模擬常數
    
    // 繪圖與計算變數
    let plateCharges = []; // 存放所有組成板子的點電荷
    let observer;
    let draggedObj = null;
    let chargeVal = 5;
    let plateDist = 150;
    
    // DOM
    let eDisplay, vDisplay, qLabel, dLabel;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      eDisplay = select('#e-val');
      vDisplay = select('#v-val');
      qLabel = select('#q-display');
      dLabel = select('#d-display');
      
      observer = new Observer(width/2, height/2); // 觀測點在中間
      updateParams(); // 初始化板子
    }

    // 當滑桿拉動時呼叫此函式
    function updateParams() {
      chargeVal = parseFloat(select('#chargeSlider').value());
      plateDist = parseFloat(select('#distSlider').value());
      
      // 更新文字顯示
      qLabel.html(chargeVal + "C");
      dLabel.html(plateDist/2 + "mm"); // 只是示意單位

      rebuildPlates();
    }

    // 重新建立平行板 (將板子視為一排點電荷)
    function rebuildPlates() {
      plateCharges = [];
      
      let startX = width/2 - PLATE_WIDTH/2;
      let gap = PLATE_WIDTH / (PLATE_CHARGES_COUNT - 1);
      
      let topY = height/2 - plateDist/2;
      let bottomY = height/2 + plateDist/2;

      // 每個點電荷分到的電荷量 (總電荷 Q 除以 數量)
      // 注意：這裡我們讓板子總帶電量 = 滑桿數值
      let unitQ = chargeVal / PLATE_CHARGES_COUNT * 2; // *2 是為了讓場強視覺效果明顯一點

      for (let i = 0; i < PLATE_CHARGES_COUNT; i++) {
        let x = startX + i * gap;
        
        // 上板 (正電荷)
        plateCharges.push({ x: x, y: topY, q: unitQ });
        // 下板 (負電荷)
        plateCharges.push({ x: x, y: bottomY, q: -unitQ });
      }
    }

    function draw() {
      background(10);
      
      // 1. 繪製板子實體 (視覺裝飾)
      drawPlateVisuals();

      // 2. 繪製電力線
      drawFieldLines();

      // 3. 觀測點
      observer.update();
      observer.display();
    }

    // --- 視覺繪圖 ---
    function drawPlateVisuals() {
      rectMode(CENTER);
      noStroke();
      
      let topY = height/2 - plateDist/2;
      let bottomY = height/2 + plateDist/2;

      // 上板 (紅)
      fill(200, 50, 50);
      rect(width/2, topY, PLATE_WIDTH + 20, 10, 5);
      
      // 下板 (藍)
      fill(50, 100, 200);
      rect(width/2, bottomY, PLATE_WIDTH + 20, 10, 5);

      // 畫電荷符號
      fill(255); textAlign(CENTER, CENTER); textSize(12); textStyle(BOLD);
      text("＋ ＋ ＋ ＋ ＋ ＋ ＋ ＋", width/2, topY);
      text("－ － － － － － － －", width/2, bottomY);
    }

    function drawFieldLines() {
      noFill(); strokeWeight(1.5);
      
      // 只從上板(正電荷) 發出電力線
      // 為了效能，不要從每個點都發，每隔幾個點發一條就好
      let step = 2; // 每隔 2 個電荷畫一條
      
      // 找出所有正電荷
      let positives = plateCharges.filter(c => c.q > 0);
      
      for (let i = 0; i < positives.length; i += step) {
        let p = positives[i];
        
        // 每一點發出 2 條線 (稍微錯開角度，營造擴散感)
        // 中間的點主要向下，邊緣的點會向外
        let linesPerPoint = 1; 
        
        for(let k=0; k<linesPerPoint; k++) {
            let startX = p.x;
            let startY = p.y + 6; // 從板子下方一點點開始
            
            let currX = startX;
            let currY = startY;

            stroke(255, 255, 255, 60); // 淡白色線
            beginShape();
            vertex(currX, currY);

            for (let s = 0; s < 400; s++) { // 步數限制
                let res = calculateField(currX, currY);
                
                // 停止條件：場太弱、出界
                if (res.E_mag < 0.05 || currX < 0 || currX > width || currY < 0 || currY > height) break;

                // 前進
                let dx = (res.Ex / res.E_mag) * 5; // step size 5
                let dy = (res.Ey / res.E_mag) * 5;
                currX += dx;
                currY += dy;
                vertex(currX, currY);

                // 停止條件：碰到下板 (簡單判斷 Y 座標)
                if (currY >= height/2 + plateDist/2 - 5) break;
            }
            endShape();
        }
      }
    }

    // --- 物理計算 (疊加原理) ---
    function calculateField(x, y) {
      let Ex = 0, Ey = 0, V = 0;
      
      // 雖然是平行板，但我們用 "多個點電荷疊加" 來模擬，
      // 這樣可以自動產生正確的邊緣效應 (Fringing field)
      for (let c of plateCharges) {
        let dx = x - c.x;
        let dy = y - c.y;
        let dSq = dx*dx + dy*dy;
        // 避免除以零，且設定一個最小距離以避免數值爆炸
        let d = sqrt(dSq);
        if (d < 5) d = 5; 
        dSq = max(dSq, 25);

        let E = (K_CONST * c.q) / dSq;
        Ex += E * (dx / d);
        Ey += E * (dy / d);
        
        V += (K_CONST * c.q) / d / 10;
      }
      return { Ex, Ey, E_mag: sqrt(Ex*Ex + Ey*Ey), V };
    }

    // --- 觀測點 (與 index.html 相同邏輯) ---
    class Observer {
      constructor(x, y) { this.x = x; this.y = y; }
      update() {
        let res = calculateField(this.x, this.y);
        this.Ex = res.Ex; this.Ey = res.Ey;
        eDisplay.html(res.E_mag.toFixed(2));
        vDisplay.html(res.V.toFixed(2));
      }
      display() {
        // 準心
        stroke('#ffe600'); strokeWeight(2); noFill();
        ellipse(this.x, this.y, 24);
        line(this.x-16, this.y, this.x+16, this.y);
        line(this.x, this.y-16, this.x, this.y+16);

        // 向量
        let len = mag(this.Ex, this.Ey);
        if (len > 0.01) {
          push(); translate(this.x, this.y); rotate(atan2(this.Ey, this.Ex));
          // 這裡的 scale 可以調整，讓平行板內部的箭頭長度適中
          let displayLen = constrain(len * 60, 20, 100); 
          stroke('#00FFFF'); strokeWeight(4); line(0, 0, displayLen, 0);
          noFill(); line(displayLen, 0, displayLen - 12, -8); line(displayLen, 0, displayLen - 12, 8);
          pop();
        }
      }
    }

    // --- 互動 ---
    function isTouchingUI(e) {
      // 排除滑桿、按鈕、選單
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.closest('#side-menu')) return true;
      return false;
    }

    function touchStarted(e) { if(isTouchingUI(e)) return true; handleStart(); return false; }
    function mousePressed(e) { if(isTouchingUI(e)) return true; handleStart(); }

    function handleStart() {
      // 平行板模式下，只有觀測點可以拖曳，板子是用滑桿控制
      if (dist(mouseX, mouseY, observer.x, observer.y) < 50) {
        draggedObj = observer;
      }
    }

    function touchMoved() { handleMove(); return false; }
    function mouseDragged() { handleMove(); }

    function handleMove() {
      if (draggedObj) {
        draggedObj.x = constrain(mouseX, 10, width-10);
        draggedObj.y = constrain(mouseY, 80, height-80); // 避開UI
      }
    }

    function touchEnded() { draggedObj = null; }
    function mouseReleased() { draggedObj = null; }

    function windowResized() { 
        resizeCanvas(windowWidth, windowHeight); 
        updateParams(); // 重繪板子位置
    }
  </script>
</body>
</html>
